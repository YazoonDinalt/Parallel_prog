# Task 3. Параллельные алгоритмы на графах

# Часть 1


В этом задании вам предлагается реализовать многопоточную версию алгоритма Дейкстры для поиска кратчайших путей во взвешенном графе с помощью структуры данных Relaxed Multi-(Priority)-Queue.

Напомним, что главная идея такого подхода основана на том, чтобы вместо одной приоритетной очереди использовать сразу N очередей с блокировкой на каждую (где N может быть равно числу потоков, хотя и необязательно), работая с ними следующим образом:
- При добавлении просто вставлять элемент в случайную очередь, требуя блокировки на неё;
- При удалении выбирать две случайные очереди, брать из них по элементу, удалять минимальный из них. При корректной модификации алгоритма Дейкстры на моменте с релаксацией вдоль нового ребра. Такая версия будет рабочей. Да, чистая логарифмическая асимптотика от такой модификации потеряется, но на практике все оказывается не так плохо.
- Поддерживать размер “очереди” в отдельной atomic-переменной. И да, не забываем про CAS-операции!

# Часть 2

Предлагается реализовать параллельную версию алгоритма Флойда на основе идеи fork-join параллелизма. Тут совсем всё просто — создаем потоки, они делают полезную работу по чанкам в массиве расстояний, потом джойним их. Собственно, и всё.

# Часть 3
Ожидается некоторое покрытие кода тестами, которые могли бы в той или иной степени убедить проверяющего в корректности решения.

Также необходимо провести эксперимент на случайно-сгенерированных графах (хотя бы 10, 100, 1000 и 100 000 вершин, файлы с графами приложить отдельно),
показывающий, как с точки зрения производительности соотносятся последовательная и параллельная версии алгоритмов.

Комментарий. Язык программирования — как в задаче про стек Трайбера